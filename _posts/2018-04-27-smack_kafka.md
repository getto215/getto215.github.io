---
title: "Kafka 아키텍처 이해를 위한 구성 요소"
tags:
  - kafka
---
"SMACK 스택을 이용한 빠른 데이터 처리 시스템(Fast Data Processing System with SMACK Stack)"에서 소개된 구성 요소를 정리합니다. Kafka 아키텍처를 이해하는데 도움이 될 만한 항목들을 기준으로 정리하였습니다. (Kafka 0.8 이상)

### 주요 설계
* 마스터가 없음(master-less)
* 메타 데이터(metadata)
  * Kafka의 메세지 상태는 consumer 레벨에서 유지 관리
  * 동일한 메시지를 여러번 배달되거나 오류로 인한 메세지 손실을 방지함
* Push와 Pull
  * producer는 메세지를 broker에 보내고 consumer는 메세지를 broker로부터 가져옴
* 보존(retention)
  * 재구독 허용
* 저장소(storage)
  * 파일 시스템에 캐싱 저장
  * 디스크 캐싱과 플러시를 설정할 수 있음
* 동기식(synchronous)
  * producer는 메세지를 브로커에 보낼 때 동기식 또는 비동기식 옵션을 제공


### 세그먼트 파일(segment file)
* 내부적으로 모든 파티션은 동일한 크기의 세그먼트 파일 세트로 표현되는 논리 로그 파일로 구성되어 있음
* 메세지가 특정 수에 도달하면 세그먼트 파일이 디스크에 플러시
* 파일이 플러시되면 consumer가 해당 메세지를 사용할 수 있음


### 오프셋(offset)
* 고유 순차 번호
* 파티션 내부의 메세지를 식별하는데 사용


### 리더(leader)
* 각 파티션마다 리더인 하나의 kafka 서버가 있음
* 구성원(follower)은 나머지 서버
* 리더는 해당 파티션에 대한 읽기 요청과 쓰기 요청을 조정
* 구성원 서버는 리더 서버의 데이터를 비동기적으로 복제. 리더가 실패하면 나머지 서버 중 하나가 새로운 리더


### 로그 컴팩션(log compaction)
* 시간 기반 메세지 보존
* 보존 정책 종류 : Coarse-grained(시간 기반), Fine-grained(메세지 기반)
* Kafka 보존 정책 : 토픽별(시간 기반), 크기 기반, 로그 컴팩션 기반
* 로그 컴팩션 보장
  * 읽기가 오프셋 0부터 시작
  * 메세지는 순차적인 오프셋을 가지고 해당 오프셋은 결코 변경되지 않음
  * 메세지 순서는 항상 보존
  * 백그라운드 스레드 그룹은 로그 세그먼트 파일을 다시 복사. 로그 앞부분에 키가 나타난 레코드는 삭제


### 메세지 압축
* 네트워크 오버헤드는 감소, 브로커 CPU 사용율(리더)은 증가
* 메세지 그룹을 압축
* 메세지 그룹이 압축되어 단일 메세지로 consumer에 제공
* 0.8.0 이전에는 consumer가 해당 메세지를 압축 해제했으나 이후 버전에서는 브로커가 처리
* 데이터 센터 간 미러링 할 경우 사용할만함

### 복제
* 복제는 메세지가 발행되고 사용, producer와 consumer 모두 복제를 알고 있음
* 하나의 복제본은 리더 역할을 함. 주키퍼는 복제본의 리더를 알고 있음
* 비동기 복제 : 리더에 저장되면 producer에 ack를 보냄. 빠르나 내결함성이 없음
* 동기 복제 : 모든 구성원에서 복제본에 대한 ack를 받을 때까지 기다린 후 producer에 ack를 보냄. 느리지만 안정적